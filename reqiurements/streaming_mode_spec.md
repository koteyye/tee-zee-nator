# Спецификация перехода на Streaming NDJSON режим (замена текущего агентского)

Документ описывает, как заменить существующий «агентский» режим на потоковый NDJSON‑стрим, основанный на `stream_spec.txt`. Актуализация: отказ от жёстко заданных разделов в коде. Структура формируется исключительно активным шаблоном ТЗ. Подход упрощён до единого текстового потока полного документа (без ключей разделов в JSON). Цель: минимизировать связность фронтенда с моделью и позволить шаблонам динамически определять структуру.

## 1. Цели (обновлено)
1. Реализовать двухпоточный стрим (status / content) поверх NDJSON (по строке — валидный JSON).
2. Корректное пустое состояние: первая пара сообщений — status(init,0) и пустой content.
3. Переработать `ResultPanel` в панель потоковой генерации целого документа (единый текст), без внутреннего знания о разделах.
4. Поле «Изменения и дополнения» отображается ТОЛЬКО после появления первой непустой текстовой порции.
5. Структура (заголовки, порядок, разделы) формируется моделью исключительно на основании активного шаблона ТЗ. Код не содержит списка секций.
6. Не задавать модель жёстко в коде — брать из конфигурации (`ConfigService`).
7. Остальной функционал (копирование, сохранение, публикация в Confluence) сохраняется.

## 2. Сравнение с текущим агентским подходом (обновлено)
| Аспект | Агентский (текущий) | Streaming NDJSON (новый) |
|-------|---------------------|---------------------------|
| Формат | Один JSON с actions / секциями | Множество строк JSON (status / content / final) |
| Управление шагами | Actions интерпретируются клиентом | Статусы с phase/progress |
| Обновление контента | Секции по ключам | Поток кумулятивного текста (инкрементальные чанки) |
| Пустое состояние | Локально | Первые две строки потока |
| Знание о разделах | Зашито в код | Только в шаблоне / выводе модели |
| Парсинг | Один большой объект | Построчное разборивание NDJSON |

## 3. Потоковые сообщения (новая модель контента)
### 3.1 Типы
1. `status`
2. `content`
3. `final`

### 3.2 Протокол фаз (не изменён)
`init → plan → structure → draft_sections → refine → validate → finalize`.

### 3.3 Правила (обновлено для единого текста)
- Первая строка: `status(init,0)`.
- Вторая строка: `content` с пустым полем (см. ниже) — обозначение чистого состояния.
- Модель НЕ использует ключи разделов. Вся структура (H1/H2 или HTML) формируется внутри текстовых чанков.
- Content строки могут быть двух форматов (рекомендуем поддержать оба для гибкости поставщиков):
  - Инкрементальное добавление: `{ "stream_type":"content", "append":"<фрагмент текста>" }`
  - Полная замена (редко, например фазовое переписывание): `{ "stream_type":"content", "full":"<полный документ целиком на текущий момент>" }`
- Клиент, получив `append`, конкатенирует текст. Получив `full`, заменяет текущее содержимое.
- Нельзя отправлять одновременно `append` и `full` в одном объекте.
- Пустое состояние задаётся сообщением: `{ "stream_type":"content", "append":"" }` или `{ "stream_type":"content", "full":"" }`.
- Итог: `final(progress=100, summary, message="Готово")`.
- Строгий NDJSON: одна строка — один JSON, без лишних символов.

### 3.4 Схемы
Status:
```
{"stream_type":"status","phase":"structure","progress":10,"message":"Формирую структуру","ts":"<ISO8601>"}
```
Content (append):
```
{"stream_type":"content","append":"## Введение\nПроект посвящён ..."}
```
Content (full):
```
{"stream_type":"content","full":"# Техническое задание\n\n## Введение..."}
```
Final:
```
{"stream_type":"final","progress":100,"message":"Готово","summary":"Сформирован полный документ"}
```

## 4. Новый системный промпт (обновлено под единый текст)
### 4.1 Шаблон (переменные)
Переменные: `{FORMAT}`, `{TEMPLATE_STRUCTURE_HINT}` (сырой текст/конспект активного шаблона), `{NOW_ISO}`.

```
Ты ИИ-помощник по созданию технического задания. Отвечай СТРОГО стримом NDJSON. Каждая строка — одиночный валидный JSON без комментариев и пояснений вне JSON.

ФАЗЫ: init → plan → structure → draft_sections → refine → validate → finalize.

ПРАВИЛА СТРИМА:
1. Первая строка: {"stream_type":"status","phase":"init","progress":0,"message":"Инициализация","ts":"<ISO8601>"}
2. Вторая строка: пустой контент: {"stream_type":"content","append":""}
3. Для постепенного вывода используй преимущественно form "append" с небольшими порциями (абзац / логический блок). Если требуется значительная переработка уже выведенного текста, пришли полную версию: {"stream_type":"content","full":"..."}.
4. НЕ используй ключи разделов — структура выражается заголовками и форматированием в тексте ({FORMAT}).
5. Прогресс повышай монотонно, финал: {"stream_type":"final","progress":100,"message":"Готово","summary":"..."}.
6. Не добавляй placeholder'ы или заглушки. Любой выданный текст должен быть финального качества для своей части.
7. Формат: {FORMAT}. Если Markdown — только стандартный синтаксис без лишних HTML. Если HTML (Confluence) — только разрешённые теги и семантические заголовки.
8. Структуру опирай на активный шаблон (контур ниже). Не изобретай произвольные разделы вне логики шаблона, но можешь адаптировать названия для ясности.
9. Строго один JSON-объект в строке. Никакого текста вне JSON.

КОНТУР ШАБЛОНА (для ориентира, не выводи дословно):
{TEMPLATE_STRUCTURE_HINT}

ЗАДАЧА: Сгенерировать цельное техническое задание высокого качества, постепенно стримя текст.
Время запроса: {NOW_ISO}.
```

### 4.2 Формирование `{TEMPLATE_STRUCTURE_HINT}`
- Из активного шаблона извлекается структура (например, заголовки или маркеры) и подставляется как многострочный контур.
- Если шаблон отсутствует — подставить строку: `(нет активного шаблона — структура на усмотрение модели)`.

## 5. Архитектура клиента (слой стрима, обновлено)
### 5.1 Новые сущности
- `StreamingSessionController` (ChangeNotifier):
  - Поля: `phase`, `progress`, `isActive`, `documentText:String`, `hasContent:bool`, `startedAt`, `lastUpdate`, `error`, `summary`, `finalized`.
  - Методы: `startSession(input)`, `abort()`, `applyStatus(msg)`, `applyAppend(text)`, `applyFull(text)`, `finalize(msg)`, `reset()`.
- Модели сообщений:
  - `StreamStatusMessage(phase, progress, message, ts)`
  - `StreamContentAppend(append)`
  - `StreamContentFull(full)`
  - `StreamFinal(progress, message, summary)`

### 5.2 Поток обработки
1. `startSession()` — reset состояния, запрос потока.
2. Построчный парсинг JSON.
3. `status` → обновить фазу / прогресс.
4. `content`:
  - Если есть ключ `append` → `documentText += append`.
  - Если есть ключ `full` → `documentText = full`.
  - Если текст непустой и `hasContent == false` → установить `hasContent = true`.
5. `final` → `finalized=true`, `progress=100`, `summary` сохранить.

### 5.3 Ошибки и устойчивость
- Невалидная строка: логировать, счётчик ошибок; >3 подряд → `abort()` с сообщением.
- Потеря соединения до final: баннер «Поток прерван. Частичный результат сохранён.».
- Пустые append подряд допустимы, но можно сворачивать (не обновлять UI).
- Таймаут (120с) без активности → мягкое завершение без summary.

### 5.4 Аборт / отмена
- Метод `abort()` закрывает поток, фазу устанавливает `finalize` и прогресс не трогает.

## 6. UI изменения
### 6.1 Замена `ResultPanel`
- Новый файл: `lib/widgets/main_screen/stream_result_panel.dart`.
- Требования (адаптировано):
  - Заголовок «Сгенерированное ТЗ». Кнопки Copy / Save / Publish активны только при наличии непустого `documentText`.
  - Статус-блок: фаза, прогрессбар, сообщение.
  - Основной скролл: один многострочный текст (`SelectableText` / markdown renderer / html renderer в зависимости от формата).
  - Пустое состояние: иконка + «Ожидаем генерацию…» до первой непустой порции.
  - Возможность копировать весь документ.
  - (Опционально) простая панель поиска по тексту (follow-up, не в scope DoD).

### 6.2 Поле «Изменения и дополнения»
- Показ: `hasContent == true`.
- Скрытие при `reset()`.

### 6.3 Визуализация фаз
- Цвет бейджа по фазе (пример):
  - init/plan: серый
  - structure/draft_sections: синий
  - refine/validate: оранжевый
  - finalize: зелёный

### 6.4 Сообщения об ошибках
- Красный блок внутри панели при `error != null`.

## 7. Интеграция с существующим кодом
### 7.1 Удаляем
- Модели `AgentAction`, `AgentResponse`, `AgentExecutor`, `AgentController` (постепенная деградация — сначала пометить @deprecated, затем удалить после миграции).

### 7.2 Новые сервисы (обновлено)
`lib/services/streaming_llm_service.dart` (идея неизменна, но без секционных апдейтов — только текстовые чанки).

`lib/services/streaming_session_controller.dart`:
```dart
class StreamingSessionController extends ChangeNotifier {
  String _document = '';
  String get document => _document;
  // ... остальные поля (phase, progress, etc.)
  void _applyAppend(String chunk) { if (chunk.isEmpty) return; _document += chunk; notifyListeners(); }
  void _applyFull(String full) { _document = full; notifyListeners(); }
}
```

### 7.3 MainScreen изменения
1. Заменить ссылки на AgentController → StreamingSessionController (Provider).
2. Кнопка «Сгенерировать» вызывает `controller.start()`.
3. Кнопка «Очистить» вызывает `controller.reset()`.
4. Перед сохранением использовать сборку итогового документа из `sections` (Markdown / HTML) — можно адаптировать существующую логику форматирования.

### 7.4 Формирование итогового документа
— Итоговый документ уже формируется моделью. Дополнительно можно добавить в конец технический футер (прогресс / время генерации) при сохранении.

## 8. Логика отображения «изменения и дополнения» (упрощено)
```dart
final showChangesField = streamingController.hasContent;
```
`hasContent` → true после первой непустой `append` или `full` с непустым текстом.

## 9. Обработка форматов (Markdown vs HTML)
- Использовать существующий `OutputFormat`.
- `{FORMAT}` = `Markdown` или `HTML (Confluence)`.
- Рендер: прежняя логика (Markdown виджет или `HtmlContentViewer`).

## 10. Edge Cases (обновлено)
| Сценарий | Поведение |
|----------|-----------|
| Нет второй пустой content строки | Клиент локально вставляет пустой content перед первым append |
| Две подряд status без content | UI просто обновляет прогресс |
| Регресс прогресса | Игнор, лог предупреждения |
| Повтор final | Игнор после первого |
| Одновременный append и full | Игнорировать строку как невалидную |
| Пустой append | Игнорировать без изменения времени обновления |
| JSON синтаксическая ошибка | Счётчик ошибок; >3 → abort |
| Нет final (таймаут) | Мягкое завершение, пометка «Частично завершено» |

## 11. Тестирование (адаптировано)
### 11.1 Unit
1. Status обновляет фазу и прогресс.
2. Append добавляет текст в конец, full заменяет полностью.
3. hasContent меняется после первого непустого append/full.
4. Регресс прогресса игнорируется.
5. Ошибочные строки не падают весь поток (до лимита).

### 11.2 Widget / Integration
1. Панель скрывает «Изменения и дополнения» до первого непустого текста.
2. Прогрессбар обновляется на status.
3. Финал активирует кнопки сохранения/публикации.
4. Abort сохраняет промежуточный текст.

## 12. Пошаговый план миграции
1. Добавить новые сервисы и контроллер (параллельно, не ломая агентский код).
2. Создать новый `stream_result_panel.dart`.
3. Интегрировать в `MainScreen` (фича-флаг или сразу замена).
4. Перенаправить кнопку генерации на streaming API.
5. Написать базовые unit-тесты контроллера.
6. Удалить (или пометить deprecated) старые агентские классы.
7. Обновить документацию (`README` если нужно).

## 13. Минимальные изменения в конфигурации
- Не добавлять константу модели в код.
- Использовать что уже указано пользователем в `ConfigService.config`.
- Если модель не настроена — отображать модальное окно / баннер «Настройте модель в конфигурации» (существующий UX сохраняем).

## 14. Формат внутреннего состояния контроллера (обновлено)
```dart
class StreamingState {
  final bool active;
  final bool finalized;
  final String phase;      // init|plan|...
  final int progress;      // 0..100
  final String document;   // полный текст
  final bool hasContent;   // true после первой непустой порции
  final String? summary;   // из final
  final String? error;     // сообщение об ошибке
}
```

## 15. Сборка итогового текста для сохранения
- Документ берётся напрямую (`document`).
- Helper может добавить футер (timestamp / progress / version placeholder).

## 16. Дальнейшие расширения (не в scope)
- Пошаговое редактирование конкретных секций по запросу.
- Инкрементальные исправления после пользовательских правок.
- Автоматическое сравнение версий.

## 17. Критерии готовности (Definition of Done, обновлено)
1. Первые два сообщения: status(init,0) и пустой content.
2. До первой непустой порции текст панель показывает пустое состояние, поле изменений скрыто.
3. Append / full корректно обновляют отображение без мерцаний.
4. Прогресс монотонно растёт, финал = 100%.
5. Кнопки действий активны только при наличии непустого документа.
6. Модель не зашита в коде; берётся из конфигурации.
7. Ошибки парсинга не ломают поток до превышения лимита.
8. Тесты контроллера и UI адаптированы под единый текст.

---
Версия документа: 1.0.0
Дата: 2025-09-09
Автор: Streaming migration spec (основано на stream_spec.txt)
