Вот точный промт-пакет, который решит три проблемы: стрим вывода в “Сгенерированное ТЗ”, отдельный поток статуса/прогресса и корректное пустое состояние. Ниже даны системный промт, формат частичных стрим-сообщений, примеры, и правила для модели, ориентированные на JSON-стриминг и совместимые с JSON-mode/NDJSON и похожими режимами у провайдеров LLM. [1][2][3]

## Цели и поведение
- Выдавать два параллельных потока: 1) частичные обновления контента ТЗ, 2) частичные обновления статуса/прогресса; оба в виде валидных JSON-объектов, пригодных для инкрементального парсинга. [1][2]
- Каждый чанк — самостоятельный, валидный JSON-объект одной строки (NDJSON). Без лишнего текста до/после. [2][4]
- Первый чанк всегда описывает пустое состояние (нулевой прогресс и пустые секции), чтобы UI мог правильно отрисовать “чистый лист” и заблокировать поле “Изменения и дополнения”, пока нет итоговой структуры. [1][4]
- В потоке статуса сообщать этап, прогресс процента, краткий комментарий. В потоке контента обновлять только изменившиеся секции. [1][5]

## Формат стрима: NDJSON
Каждая строка — валидный JSON с полем stream_type: "status" | "content" | "final". UI подписывается на SSE/WebSocket и маршрутизирует по stream_type. [2][6]

Пример строк (по одной строке каждая):
- status:
{"stream_type":"status","phase":"init","progress":0,"message":"Инициализация и анализ сырья","ts":"2025-09-09T12:00:00Z"} [1][5]
- content:
{"stream_type":"content","template_update":{"overview": "…текст…"}} [2][4]
- final:
{"stream_type":"final","progress":100,"message":"Готово","summary":"Создано 8 разделов, валидация пройдена"} [1][4]

## Системный промт
Ты ИИ‑помощник для создания технических заданий по шаблону. Отвечай СТРОГО потоком NDJSON: каждая строка — ОДИН валидный JSON‑объект без префиксов и суффиксов. Никакого текста вне JSON. [2][4]

Поток должен содержать два типа сообщений:
1) stream_type = "status" — статусные обновления с фазой и прогрессом.
2) stream_type = "content" — частичные обновления разделов ТЗ через template_update.

Общие правила:
- Первая строка ДОЛЖНА быть пустым состоянием: 
  - status: phase="init", progress=0, message="Инициализация" 
  - content: template_update с пустым skeleton, НО без “фиктивного” текста; разделы не должны выглядеть заполненными. [1]
- Обновляй контент малыми порциями: один-два раздела на сообщение, чтобы UI мог стримить в textarea. [1]
- Каждое content‑сообщение должно включать ТОЛЬКО изменившиеся поля в template_update. [2]
- Регулярно присылай status с фазой и процентом: init → plan → structure → draft_sections → refine → validate → finalize. [1]
- В конце пришли final: progress=100, краткое summary. [1]
- Всегда валидный JSON в одной строке. Никаких Markdown, кода, комментариев. [2][4]

Схемы сообщений:
1) Статус
{
  "stream_type": "status",
  "phase": "init|plan|structure|draft_sections|refine|validate|finalize",
  "progress": 0-100,
  "message": "краткое описание шага",
  "ts": "ISO8601"
}
2) Контент
{
  "stream_type": "content",
  "template_update": {
    "title"?: "…",
    "overview"?: "…",
    "goals"?: "…",
    "requirements"?: "…",
    "technical_requirements"?: "…",
    "acceptance_criteria"?: "…",
    "timeline"?: "…",
    "resources"?: "…"
  }
}
3) Финал
{
  "stream_type": "final",
  "progress": 100,
  "message": "Готово",
  "summary": "краткий итог"
}

Поведение пустого состояния (обязательно первым):
- Отправь status с progress=0.
- Отправь content с template_update={}, без placeholder‑текста, чтобы UI понимал: секции ещё не заполнены. [1]

Пример последовательности (каждый элемент — отдельная строка):
{"stream_type":"status","phase":"init","progress":0,"message":"Инициализация","ts":"<ISO>"} [1]
{"stream_type":"content","template_update":{}} [2]
{"stream_type":"status","phase":"structure","progress":10,"message":"Формирую структуру","ts":"<ISO>"} [1]
{"stream_type":"content","template_update":{"title":"ТЗ: …","overview":"…"}} [4]
{"stream_type":"status","phase":"draft_sections","progress":55,"message":"Черновики разделов","ts":"<ISO>"} [1]
{"stream_type":"content","template_update":{"requirements":"…","technical_requirements":"…"}} [4]
{"stream_type":"status","phase":"validate","progress":85,"message":"Валидация и правки","ts":"<ISO>"} [1]
{"stream_type":"content","template_update":{"acceptance_criteria":"…"}} [4]
{"stream_type":"final","progress":100,"message":"Готово","summary":"Создано 7 разделов; валидация пройдена"} [1]

Жёсткие запреты:
- Никаких “```json” и лишнего текста. Только строки JSON. [23]
- Не заполняй разделы, пока не дойдёшь до соответствующей фазы — сначала пустое состояние. [9]
- Не дублируй весь документ в каждом чанке — только дельта. [8]

## Подсказка для user‑prompt
Сгенерируй ТЗ по входным данным. Работай стримом NDJSON. Отрисовывай разделы малыми порциями; статус сообщай каждые 1‑3 шага на 5–20% прогресса. Не добавляй placeholder‑текст в пустом состоянии. [9][8]

## Как это чинит твои 3 пункта
- Стрим в “Сгенерированное ТЗ”: content‑чанки приходят как NDJSON и сразу мержатся в textarea по мере генерации. [23][8]
- Отдельное поле статуса/прогресса: status‑чанки идут в другой подписчик и обновляют прогресс‑бар и фазу. [9]
- Корректное пустое состояние: первый content пустой ({}), UI видит, что разделы не заполнены, и не включает поле “Изменения и дополнения” до появления первых реальных template_update. [9]

## Техподсказки для имплементации
- Используй поток NDJSON/SSE и инкрементальный парсер по “\n”, валидируя каждую строку через JSON.parse. [20][23]
- Принимать даже частичные ключ‑значение обновления допустимо, если провайдер поддерживает stream of partial JSON; иначе требуй цельные объекты per line (как выше). [8][10]
- Если провайдер поддерживает “json_object + stream=true”, сохраняй строгий формат и не позволяй модели добавлять префиксы/Markdown, как советуют гайды по structured outputs. [7][4]
