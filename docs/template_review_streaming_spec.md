# Спецификация: Стриминговое ревью и автоправка шаблонов

Дата: 2025-09-11  
Статус: Draft (к имплементации)  
Автор: авто-генерация (адаптировать при необходимости)

## 1. Цели
Вместо одноразового синхронного ревью шаблона внедрить потоковый (streaming NDJSON) процесс анализа и — при наличии замечаний — интерактивный потоковый режим автоправки с возможностью принять или отклонить предложенные изменения.

## 2. Требования (чеклист)
- [ ] Потоковое ревью (LLM стрим вместо единого ответа)
- [ ] Системный промт роли «методолога» (анализ, не вносит правки)
- [ ] На вход ревью: текущий контент шаблона
- [ ] Тег-триггеры в ответе ревью:
  - [КРИТИЧЕСКОЕ ЗАМЕЧАНИЕ] (существующий)
  - [НЕЗНАЧИТЕЛЬНОЕ ЗАМЕЧАНИЕ] (новый)
- [ ] Поле UI «Ревью шаблона» (многострочное, read-only, заполняется по стриму)
- [ ] Индикатор статуса (красный / оранжевый / зеленый)
- [ ] Блокировка сохранения при критичных замечаниях
- [ ] Чекбокс «Игнорировать ревью» для обхода блокировки только при критичных
- [ ] Кнопка «Исправить» появляется при любых замечаниях (critical | minor)
- [ ] Режим Fix: новый системный промт, LLM стримит уже исправленный контент
- [ ] Буфер правок (контент не перезаписывает оригинал до «Принять»)
- [ ] Кнопки «Принять» / «Отклонить» после завершения стрима Fix
- [ ] «Принять» сохраняет правки в основное поле «Контент шаблона»
- [ ] «Отклонить» откатывает к оригиналу
- [ ] Повторное ревью после принятия (кнопка остаётся доступной)
- [ ] Обработка отмены/ошибок стрима (UI уведомление, возможность перезапуска)
- [ ] Парсер тегов устойчив к инкрементальному поступлению текста
- [ ] Возможность расширять список тегов без лома UI

## 3. Пользовательский флоу
1. Пользователь редактирует «Контент шаблона» → нажимает «Ревью».
2. UI: поле «Ревью шаблона» очищается, состояние = Reviewing, лоадер / прогресс.
3. Стрим собирает текст ответа. По мере получения инкрементально парсим теги.
4. По завершении:
   - Нет тегов → статус OK (зелёный), сохранение разрешено.
   - Есть [НЕЗНАЧИТЕЛЬНОЕ ЗАМЕЧАНИЕ] → оранжевый индикатор, кнопка «Исправить», сохранение разрешено.
   - Есть [КРИТИЧЕСКОЕ ЗАМЕЧАНИЕ] → красный индикатор, сохранение заблокировано, чекбокс «Игнорировать ревью» снимает блокировку.
5. Если пользователь нажимает «Исправить»:
   - Запускается режим Fix: системный промт для исправления.
   - Стрим наполняет временный буфер (fixBuffer) — НЕ сразу в главное поле.
   - Окончание стрима: показываем дифф (опционально) и кнопки «Принять» / «Отклонить».
6. «Принять»: fixBuffer → content, сбрасываем буфер, состояние OK (потребуется повторное ревью при желании).
7. «Отклонить»: отбрасываем fixBuffer, возвращаемся к состоянию post-review (с замечаниями).

## 4. Состояния (FSM)
```
Idle -> Reviewing -> ReviewCompleted{ok|minor|critical}
ReviewCompleted{minor|critical} --(Fix)--> Fixing -> FixCompleted
FixCompleted --(Accept)--> Idle (с обновлённым контентом)
FixCompleted --(Reject)--> ReviewCompleted{minor|critical}
ЛюбоеСтримовое -> Error -> (Retry)
```

## 5. Модель состояния контроллера
```dart
enum TemplateReviewPhase { idle, reviewing, reviewCompleted, fixing, fixCompleted, error }
enum TemplateReviewSeverity { ok, minor, critical }

class TemplateReviewController extends ChangeNotifier {
  TemplateReviewPhase phase;
  TemplateReviewSeverity severity; // ok|minor|critical
  String reviewText;                // накапливаемый вывод ревью
  String? fixBuffer;                // кандидат обновлённого контента
  String? errorMessage;
  String originalContentSnapshot;   // для отката при Fix
  bool ignoreCritical;              // чекбокс обхода блокировки
  DateTime? lastReviewedAt;

  bool get canSave => severity != TemplateReviewSeverity.critical || ignoreCritical;
}
```

## 6. Новые eventType (NDJSON)
| Event | Режим | Назначение |
|-------|-------|------------|
| review_chunk | Review | Инкрементальная часть текста анализа |
| review_complete | Review | Финал анализа |
| fix_chunk | Fix | Инкрементальная часть исправленного шаблона |
| fix_complete | Fix | Финал исправления |
| error | Любой | Ошибка потока |

Парсер NDJSON дополняется маппингом eventType → соответствующий обработчик в контроллере.

## 7. Промты
### 7.1 System (Review)
```
Ты выступаешь как строгий методолог технической документации.
Твоя задача: проанализировать предоставленный шаблон на полноту, структурную согласованность, корректность формулировок, логическую целостность.
Правила:
1. НЕ изменяй текст шаблона – только анализ.
2. Если есть критические несоответствия (препятствуют использованию)
   выведи ОТДЕЛЬНОЙ строкой: [КРИТИЧЕСКОЕ ЗАМЕЧАНИЕ]
3. Если есть только некритические улучшения, выведи ОТДЕЛЬНОЙ строкой: [НЕЗНАЧИТЕЛЬНОЕ ЗАМЕЧАНИЕ]
4. Можно вывести оба тега (критический приоритет выше). Каждый тег строго одной строкой без дополнительного текста.
5. Если всё корректно – явно напиши "Шаблон корректен." и не выводи теги.
6. После тегов (если есть) дай структурированный список пояснений.
7. Не добавляй исправлений контента.
```

### 7.2 User (Review)
```
<ТЕКУЩИЙ_КОНТЕНТ_ШАБЛОНА>
```

### 7.3 System (Fix)
```
Ты редактор. Тебе дан исходный шаблон и результаты ревью.
Синтезируй единый, полностью исправленный вариант шаблона в Markdown.
Правила:
1. Верни ТОЛЬКО новый текст шаблона без пояснений, тегов и комментариев.
2. Сохраняй стиль, структуру и язык.
3. Устрани выявленные критические и незначительные замечания по максимуму.
```

### 7.4 User (Fix)
```
Исходный шаблон:
-----
<ОРИГИНАЛ>
-----
Результат ревью:
-----
<REVIEW_TEXT>
-----
```

## 8. Теги и парсинг
Константы:
```dart
const criticalTag = '[КРИТИЧЕСКОЕ ЗАМЕЧАНИЕ]';
const minorTag = '[НЕЗНАЧИТЕЛЬНОЕ ЗАМЕЧАНИЕ]';
```
Алгоритм:
1. По поступлению review_chunk апдейтим накопительный буфер.
2. Инкрементально проверяем только новые добавленные символы.
3. Разбиваем на строки `split(RegExp(r'\r?\n'))`.
4. Trim → сравниваем строго с тегами.
5. `if (critical) severity=critical (приоритет) else if (minor && !critical) severity=minor else ok`.
6. Изменение severity → notifyListeners.

## 9. Обновления UI
Компоненты (примерные):
- TemplateEditorPanel
  - TextField «Контент шаблона» (editable)
  - New: Read-only multiline «Ревью шаблона» (auto scroll)
  - StatusIndicator (цвет/иконка + текст)
  - Row кнопок: [Ревью] [Исправить]* [Принять]* [Отклонить]*
  - Checkbox «Игнорировать ревью» (visible only if severity=critical)

Правила видимости:
- «Ревью» видно в phase ∈ {idle, reviewCompleted}
- «Исправить» видно если phase=reviewCompleted && severity ∈ {minor, critical}
- «Принять» / «Отклонить» видно если phase=fixCompleted
- Поле «Контент шаблона» readonly пока phase ∈ {reviewing, fixing}
- Save кнопка (внешняя) disabled если !controller.canSave

## 10. API / Сервисы
Расширение `StreamingLLMService` (или аналог) методами:
```dart
Stream<LLMStreamEvent> streamTemplateReview({required String content, required String model});
Stream<LLMStreamEvent> streamTemplateFix({required String original, required String reviewText, required String model});
```
`LLMStreamEvent` уже содержит `eventType` + `data`. Новые eventType перечислены выше.

## 11. Обработка ошибок
Типы ошибок:
1. Сетевая (timeout / disconnect)
2. Парсинг NDJSON
3. Некорректный формат ответа (например, пустое ревью)

Поведение:
- phase=error, errorMessage заполнено
- Кнопки: «Повторить ревью» / «Отмена»
- При Fix ошибке – возвращаемся в reviewCompleted (с сохранением предыдущего ревью)

## 13. Пошаговая имплементация (итерации)
1. Контроллер состояния + статический (нестриминговый) мок событий для UI
2. Интеграция стримингового review (без Fix)
3. Добавление Fix режима (стрим) + буфер
4. UI финализация (индикаторы, чекбокс, кнопки)
5. ТестыFSM + парсинг тегов
6. Обработка ошибок / retry
7. Документация / рефактор

## 14. Персистентность (опционально в v2)
- Hive box `template_review_meta` c ключом по template.id
- Сохраняем: lastStatus, lastReviewedAt, lastReviewText, lastSeverity
- Позволяет показывать «Последнее ревью: 5 мин назад»

## 15. Расширяемость
- Добавить новый тег: достаточно зарегистрировать в массиве известных тегов и UI маппинг (цвет / приоритет)
- Severity можно ранжировать численно (critical=2, minor=1, ok=0)

## 16. Риски и смягчение
| Риск | Смягчение |
|------|-----------|
| LLM выдаёт правки уже в режиме Review | Жёстко описать инструкцию + тест на отсутствие тегов при Fix |
| Задержки сети → пользователь кликает повторно | Кнопки дизейблить при active stream |
| Теги в теле анализа (не отдельной строкой) | Строгое условие: сравнение после trim всей строки |
| Длинный текст ревью вызывает лаг скролла | Использовать ListView + append / или SingleChildScrollView с `addPostFrameCallback` автоскролла |

## 17. Минимальные изменения существующего кода
- Не ломаем `TemplateService`
- Добавляем новый `TemplateReviewController`
- Расширяем `streaming_llm_service.dart` (или выделяем отдельный `template_review_service.dart` поверх общего стриминга)
- UI модуль для панели шаблона (например, `template_review_panel.dart`)

## 18. Псевдокод контроллера
```dart
void startReview(String content, String model) {
  phase = TemplateReviewPhase.reviewing;
  severity = TemplateReviewSeverity.ok;
  reviewText = '';
  notifyListeners();
  streamTemplateReview(content: content, model: model).listen((e) {
    switch(e.type) {
      case 'review_chunk':
        _appendReview(e.text);
        _parseTagsIncremental();
        break;
      case 'review_complete':
        phase = TemplateReviewPhase.reviewCompleted;
        lastReviewedAt = DateTime.now();
        notifyListeners();
        break;
      case 'error':
        phase = TemplateReviewPhase.error;
        errorMessage = e.text;
        notifyListeners();
    }
  });
}
```

## 19. Открытые вопросы
1. Нужна ли подсветка диффа при Fix? (предложение: v2) - да подстветка нужна
2. Лимит длины ревью? (можно обрезать > 50k символов) - безлимита
3. Выбор отдельной модели для Review / Fix или одна? (в AppConfig есть reviewModel — использовать её; для Fix можно fallback на основную модель генерации) - используем одну и ту же модель, что для ревью, что для fix

## 20. Готовность к реализации
После утверждения данного файла можно начинать с итерации 1 (контроллер + мок стримов) и последовательно довести до полной функциональности.

---
Конец спецификации.
